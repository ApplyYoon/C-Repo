# a의 메모리 주소를 출력할 때 (void*)를 붙이는 이유?  
예제 코드: printf("%p", (void*)&a)  
-> C 표준에 "%p 형식 지정자는 void* 타입 인자를 기대한다." 라고 명시됨.  
즉, printf("%p", &a)는 형식 위반. (컴파일러에 따라 작동은 가능)  
위 예제 코드는 "a의 주소를 void* 형식으로 바꿔서 표준 규칙에 맞게 출력하겠다"라는 뜻이다.  
## 왜 void* 인가?
- void*는 "모든 포인터 타입의 공용 타입"  
(int*, double*, char* 전부 변환 가능)  
- 실제 주소의 값은 변하지 않음
단지 타입 정보(int, double 등)을 제거한 순수한 주소로 취급함
